<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trabalho Prático I: src/main.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Trabalho Prático I
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">main.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &quot;../includes/Graph.h&quot;</code><br />
<code>#include &quot;../includes/VertexEdge.h&quot;</code><br />
<code>#include &quot;../includes/Database.h&quot;</code><br />
<code>#include &quot;../includes/Station.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLarCapSolution.html">LarCapSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCompareVertex.html">CompareVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5fdc7c2edd244e26bd1ccd70e156104a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a5fdc7c2edd244e26bd1ccd70e156104a">getInput</a> ()</td></tr>
<tr class="separator:a5fdc7c2edd244e26bd1ccd70e156104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807f5ace297f4f5a2624a4c6fec18ece"><td class="memItemLeft" align="right" valign="top">Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a807f5ace297f4f5a2624a4c6fec18ece">initGraph</a> ()</td></tr>
<tr class="separator:a807f5ace297f4f5a2624a4c6fec18ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af4ba76b7e93dd429212e1c6cde7866"><td class="memItemLeft" align="right" valign="top">Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a2af4ba76b7e93dd429212e1c6cde7866">initReducedGraph</a> (const vector&lt; pair&lt; string, string &gt; &gt; &amp;exclude)</td></tr>
<tr class="separator:a2af4ba76b7e93dd429212e1c6cde7866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8597a457a3e2864c05e946b7e75e931d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structLarCapSolution.html">LarCapSolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a8597a457a3e2864c05e946b7e75e931d">largestCapPair</a> (Graph network)</td></tr>
<tr class="separator:a8597a457a3e2864c05e946b7e75e931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac131ea73badd73cf63f4ccc028fa2a8b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ac131ea73badd73cf63f4ccc028fa2a8b">transportationNeed</a> (Graph &amp;network, const function&lt; bool(int id, const string &amp;name)&gt; &amp;compare, string const &amp;name)</td></tr>
<tr class="separator:ac131ea73badd73cf63f4ccc028fa2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c9dca2082e2229e381fe69d3aca13d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#aa4c9dca2082e2229e381fe69d3aca13d">topKMunDistr</a> (Graph &amp;network, unsigned k)</td></tr>
<tr class="separator:aa4c9dca2082e2229e381fe69d3aca13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e39babbb1699fef4e7a2217148fa4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ac0e39babbb1699fef4e7a2217148fa4e">maxSimTrainStation</a> (Graph network, const string &amp;name)</td></tr>
<tr class="separator:ac0e39babbb1699fef4e7a2217148fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58437c86bb001f27343d6e794fe78e72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a58437c86bb001f27343d6e794fe78e72">findMinResidualAlongPath</a> (Vertex *s, Vertex *t)</td></tr>
<tr class="separator:a58437c86bb001f27343d6e794fe78e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ac6da29612cb1f4d6b8107fef3308"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#aa07ac6da29612cb1f4d6b8107fef3308">augmentFlowAlongPath</a> (Vertex *s, Vertex *t, int f)</td></tr>
<tr class="separator:aa07ac6da29612cb1f4d6b8107fef3308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fe6ae067c9088718f224784fdbe09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ac4fe6ae067c9088718f224784fdbe09f">topkSegmentFailureAux</a> (Graph *g)</td></tr>
<tr class="separator:ac4fe6ae067c9088718f224784fdbe09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada73a3ad77ce7f795adc7bac897b2a35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ada73a3ad77ce7f795adc7bac897b2a35">topkSegmentFailureDisable</a> (Graph *g)</td></tr>
<tr class="separator:ada73a3ad77ce7f795adc7bac897b2a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbfce7f33ac298c235447d68982b85f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a9bbfce7f33ac298c235447d68982b85f">sortVertexByAffected</a> (Vertex *v1, Vertex *v2)</td></tr>
<tr class="separator:a9bbfce7f33ac298c235447d68982b85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4170d7bd6e15ced02f6c2a7807aa5ffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a4170d7bd6e15ced02f6c2a7807aa5ffa">topkSegmentFailure</a> (Graph *g, int k)</td></tr>
<tr class="separator:a4170d7bd6e15ced02f6c2a7807aa5ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c2926dd9b0968badf463aaf4f91422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#a59c2926dd9b0968badf463aaf4f91422">displayMenu</a> ()</td></tr>
<tr class="separator:a59c2926dd9b0968badf463aaf4f91422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> ()</td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa07ac6da29612cb1f4d6b8107fef3308" name="aa07ac6da29612cb1f4d6b8107fef3308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07ac6da29612cb1f4d6b8107fef3308">&#9670;&#160;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm updates the flow along the augmentation path from the sink to the source. Time Complexity: O(V) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Vertex, represents the source node </td></tr>
    <tr><td class="paramname">t</td><td>Vertex, represents the sink node </td></tr>
    <tr><td class="paramname">f</td><td>int, represents the flow to be augmented </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c2926dd9b0968badf463aaf4f91422" name="a59c2926dd9b0968badf463aaf4f91422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c2926dd9b0968badf463aaf4f91422">&#9670;&#160;</a></span>displayMenu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void displayMenu </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58437c86bb001f27343d6e794fe78e72" name="a58437c86bb001f27343d6e794fe78e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58437c86bb001f27343d6e794fe78e72">&#9670;&#160;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm calculates the minimum residual capacity along a path from the source vertex to the target vertex in a given flow network. Time Complexity: O(V) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Vertex, source node </td></tr>
    <tr><td class="paramname">t</td><td>Vertex, sink node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f int, represents the minimum residual capacity of the path from vertex source to vertex sink </dd></dl>

</div>
</div>
<a id="a5fdc7c2edd244e26bd1ccd70e156104a" name="a5fdc7c2edd244e26bd1ccd70e156104a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdc7c2edd244e26bd1ccd70e156104a">&#9670;&#160;</a></span>getInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string getInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a807f5ace297f4f5a2624a4c6fec18ece" name="a807f5ace297f4f5a2624a4c6fec18ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807f5ace297f4f5a2624a4c6fec18ece">&#9670;&#160;</a></span>initGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph initGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2af4ba76b7e93dd429212e1c6cde7866" name="a2af4ba76b7e93dd429212e1c6cde7866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af4ba76b7e93dd429212e1c6cde7866">&#9670;&#160;</a></span>initReducedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph initReducedGraph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; string, string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>exclude</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8597a457a3e2864c05e946b7e75e931d" name="a8597a457a3e2864c05e946b7e75e931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8597a457a3e2864c05e946b7e75e931d">&#9670;&#160;</a></span>largestCapPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structLarCapSolution.html">LarCapSolution</a> largestCapPair </td>
          <td>(</td>
          <td class="paramtype">Graph&#160;</td>
          <td class="paramname"><em>network</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm finds the pair of stations with the highest max flow by brute forcing every possible pair of stations. Time complexity: O(|V|^2 * |E| * (|V| + |E|)). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>Graph, railway network represented as a weighted, directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>res, <a class="el" href="structLarCapSolution.html">LarCapSolution</a>, a data structure containing a vector of pairs of stations. and an integer containing the max flow between this/these pair(s) of station(s). </dd></dl>

</div>
</div>
<a id="ae66f6b31b5ad750f1fe042a706a4e3d4" name="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f6b31b5ad750f1fe042a706a4e3d4">&#9670;&#160;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0e39babbb1699fef4e7a2217148fa4e" name="ac0e39babbb1699fef4e7a2217148fa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e39babbb1699fef4e7a2217148fa4e">&#9670;&#160;</a></span>maxSimTrainStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maxSimTrainStation </td>
          <td>(</td>
          <td class="paramtype">Graph&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm finds the maximum number of trains that can simultaneously arrive at a given station. It works by creating a super source node that connects to all source stations (the ones with only one edge in their adjacency list) with an infinite capacity, and then calculating the max flow between the super source and the desired station. Time complexity: O(|E| * (|V| + |E|)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>Graph, railway network represented as a weighted, directed graph. </td></tr>
    <tr><td class="paramname">name</td><td>std::string, string of characters containing the station name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max_flow, int, maximum flow between the created super source and sink station (name) </dd></dl>

</div>
</div>
<a id="a9bbfce7f33ac298c235447d68982b85f" name="a9bbfce7f33ac298c235447d68982b85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbfce7f33ac298c235447d68982b85f">&#9670;&#160;</a></span>sortVertexByAffected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sortVertexByAffected </td>
          <td>(</td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm sorts the list of vertices in descending order of the percentage of affected stations </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vertex</td><td>v1 </td></tr>
    <tr><td class="paramname">Vertex</td><td>v2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted vector of vertexes </dd></dl>

</div>
</div>
<a id="aa4c9dca2082e2229e381fe69d3aca13d" name="aa4c9dca2082e2229e381fe69d3aca13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c9dca2082e2229e381fe69d3aca13d">&#9670;&#160;</a></span>topKMunDistr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topKMunDistr </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the top k Municipalities and Districts sorted by their transportation needs. Time complexity: O(|E| * (|V| + |E|)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>Graph, railway network represented as a weighted, directed graph. </td></tr>
    <tr><td class="paramname">k</td><td>int, number of districts/municipalities to show </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4170d7bd6e15ced02f6c2a7807aa5ffa" name="a4170d7bd6e15ced02f6c2a7807aa5ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4170d7bd6e15ced02f6c2a7807aa5ffa">&#9670;&#160;</a></span>topkSegmentFailure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topkSegmentFailure </td>
          <td>(</td>
          <td class="paramtype">Graph *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm starts with calculating the normal flow of each station. Then it makes the edge inserted by the user unavailable, and calculates the flow of each station again. It then compares the flows and shows the top k most affected stations Time Complexity: O((V+E)+(V^2)+E+(V^2)+(V*log(V))+k) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g, represents the graph </td></tr>
    <tr><td class="paramname">int</td><td>k, represents the number of most affected stations to show </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4fe6ae067c9088718f224784fdbe09f" name="ac4fe6ae067c9088718f224784fdbe09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4fe6ae067c9088718f224784fdbe09f">&#9670;&#160;</a></span>topkSegmentFailureAux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topkSegmentFailureAux </td>
          <td>(</td>
          <td class="paramtype">Graph *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm calculates the flow of each vertex that has not been calculated The result is stored as the vertex's indegree The indegree represents the flow of the vertex and is later used to determine which stations are most affected by the segment failure Time Complexity: O(V^2) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g, represents the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada73a3ad77ce7f795adc7bac897b2a35" name="ada73a3ad77ce7f795adc7bac897b2a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada73a3ad77ce7f795adc7bac897b2a35">&#9670;&#160;</a></span>topkSegmentFailureDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topkSegmentFailureDisable </td>
          <td>(</td>
          <td class="paramtype">Graph *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This algorithm calculates the flow of each vertex, when the edge is unavailable The IndegreeUnavailable represents the flow of the vertex with the edge unavailable and is later used to determine which stations are most affected by the segment failure Time Complexity: O(V^2) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Graph</td><td>g, represents the graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac131ea73badd73cf63f4ccc028fa2a8b" name="ac131ea73badd73cf63f4ccc028fa2a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac131ea73badd73cf63f4ccc028fa2a8b">&#9670;&#160;</a></span>transportationNeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned transportationNeed </td>
          <td>(</td>
          <td class="paramtype">Graph &amp;&#160;</td>
          <td class="paramname"><em>network</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(int id, const string &amp;name)&gt; &amp;&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the transportation needs for a specific district or municipality. Time complexity: O(|E| * (|V| + |E|)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">network</td><td>Graph, railway network represented as a weighted, directed graph. </td></tr>
    <tr><td class="paramname">compare</td><td>bool function, function that is used to check if the current searched vertex is in the district or municipality we want to avoid or use. </td></tr>
    <tr><td class="paramname">name</td><td>string, name of the district or municipality we're currently calculating the transportation usage for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned, transportation need for a given district/municipality. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
